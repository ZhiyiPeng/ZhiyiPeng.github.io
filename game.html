<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOGGY JUMP ğŸ¶</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const DogJumpGame = () => {
  const [gameState, setGameState] = useState('menu'); // menu, playing, gameOver
  const [difficulty, setDifficulty] = useState('medium');
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const frameCountRef = useRef(0);
  
  // æ¸¸æˆå¯¹è±¡çŠ¶æ€
  const dogRef = useRef({
    x: 100,
    y: 300,
    width: 50,
    height: 40,
    velocityY: 0,
    isJumping: false,
    isCharging: false,
    jumpPower: 0,
    maxJumpPower: 18,
    legPhase: 0
  });
  
  const obstaclesRef = useRef([]);
  const cloudsRef = useRef([]);
  const jumpKeyPressedRef = useRef(false);
  const gameTimeRef = useRef(0);
  
  const difficultySettings = {
    easy: { baseSpeed: 3.5, maxSpeed: 7, spawnInterval: 2200, minSpawnInterval: 1400 },
    medium: { baseSpeed: 5, maxSpeed: 10, spawnInterval: 1800, minSpawnInterval: 1000 },
    hard: { baseSpeed: 7, maxSpeed: 14, spawnInterval: 1400, minSpawnInterval: 700 }
  };

  // ç»˜åˆ¶åœ†è§’çŸ©å½¢çš„è¾…åŠ©å‡½æ•°
  const drawRoundedRect = (ctx, x, y, width, height, radius) => {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  };

  // åˆå§‹åŒ–äº‘æœµ
  const initClouds = () => {
    return Array.from({ length: 5 }, () => ({
      x: Math.random() * 800,
      y: Math.random() * 150 + 20,
      speed: Math.random() * 0.5 + 0.2,
      size: Math.random() * 40 + 20
    }));
  };

  useEffect(() => {
    const handleInputStart = (e) => {
      if (e.code === 'Space' || e.type === 'touchstart') {
        if (e.cancelable) e.preventDefault();
        if (gameState === 'playing') {
          jumpKeyPressedRef.current = true;
          // ä»…åœ¨å°ç‹—åœ¨åœ°é¢ä¸Šæ—¶æ‰èƒ½å¼€å§‹è“„åŠ›
          if (dogRef.current.y >= 300) {
            dogRef.current.isCharging = true;
          }
        } else if (gameState === 'gameOver' || gameState === 'menu') {
          startGame();
        }
      }
    };

    const handleInputEnd = (e) => {
      if (e.code === 'Space' || e.type === 'touchend') {
        jumpKeyPressedRef.current = false;
        if (gameState === 'playing' && dogRef.current.y >= 300) {
          dogRef.current.velocityY = -dogRef.current.jumpPower - 5; // åŸºç¡€è·³è·ƒ + è“„åŠ›
          dogRef.current.isJumping = true;
          dogRef.current.isCharging = false;
        }
      }
    };

    window.addEventListener('keydown', handleInputStart);
    window.addEventListener('keyup', handleInputEnd);
    window.addEventListener('touchstart', handleInputStart, { passive: false });
    window.addEventListener('touchend', handleInputEnd);

    return () => {
      window.removeEventListener('keydown', handleInputStart);
      window.removeEventListener('keyup', handleInputEnd);
      window.removeEventListener('touchstart', handleInputStart);
      window.removeEventListener('touchend', handleInputEnd);
    };
  }, [gameState]);

  const startGame = () => {
    dogRef.current = {
      x: 100,
      y: 300,
      width: 50,
      height: 40,
      velocityY: 0,
      isJumping: false,
      isCharging: false,
      jumpPower: 0,
      maxJumpPower: 18,
      legPhase: 0
    };
    obstaclesRef.current = [];
    cloudsRef.current = initClouds();
    gameTimeRef.current = 0;
    frameCountRef.current = 0;
    setScore(0);
    setGameState('playing');
  };

  useEffect(() => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const settings = difficultySettings[difficulty];
    
    let lastSpawnTime = Date.now();
    let lastObstacleEnd = canvas.width;

    const drawDog = (ctx, dog) => {
      ctx.save();
      ctx.translate(dog.x, dog.y);

      // èº«ä½“æ—‹è½¬æ•ˆæœï¼ˆè·³è·ƒæ—¶ï¼‰
      if (dog.y < 300) {
        ctx.rotate(dog.velocityY * 0.02);
      }

      // ç»˜åˆ¶èº«ä½“ (æ£•è‰²)
      ctx.fillStyle = '#8B4513';
      ctx.beginPath();
      drawRoundedRect(ctx, 0, 0, dog.width, dog.height - 10, 10);
      ctx.fill();

      // å¤´éƒ¨
      ctx.beginPath();
      drawRoundedRect(ctx, dog.width - 15, -15, 25, 25, 8);
      ctx.fill();

      // è€³æœµ
      ctx.fillStyle = '#5D2E0A';
      ctx.beginPath();
      ctx.ellipse(dog.width + 5, -15, 5, 10, Math.PI/4, 0, Math.PI * 2);
      ctx.fill();

      // çœ¼ç›
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(dog.width + 2, -8, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(dog.width + 3, -8, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // è…¿éƒ¨åŠ¨ç”»
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 6;
      const legMotion = dog.y < 300 ? 10 : Math.sin(frameCountRef.current * 0.2) * 10;
      
      // å‰è…¿
      ctx.beginPath();
      ctx.moveTo(dog.width - 10, dog.height - 10);
      ctx.lineTo(dog.width - 5 + legMotion, dog.height);
      ctx.stroke();
      
      // åè…¿
      ctx.beginPath();
      ctx.moveTo(10, dog.height - 10);
      ctx.lineTo(5 - legMotion, dog.height);
      ctx.stroke();

      ctx.restore();

      // è“„åŠ›æ¡
      if (dog.isCharging && dog.y >= 300) {
        const barWidth = (dog.jumpPower / dog.maxJumpPower) * dog.width;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(dog.x, dog.y - 30, dog.width, 6);
        ctx.fillStyle = '#ff4757';
        ctx.fillRect(dog.x, dog.y - 30, barWidth, 6);
      }
    };

    const gameLoop = () => {
      frameCountRef.current++;
      gameTimeRef.current += 0.016;
      setScore(Math.floor(gameTimeRef.current * 10));
      
      const currentSpeed = Math.min(
        settings.maxSpeed,
        settings.baseSpeed + gameTimeRef.current * 0.08
      );

      // æ¸…å±èƒŒæ™¯
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#a1c4fd');
      gradient.addColorStop(1, '#c2e9fb');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ç»˜åˆ¶è£…é¥°æ€§äº‘æœµ
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      cloudsRef.current.forEach(cloud => {
        cloud.x -= cloud.speed;
        if (cloud.x + cloud.size < 0) cloud.x = canvas.width + 50;
        ctx.beginPath();
        ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
        ctx.arc(cloud.x + 20, cloud.y - 10, cloud.size * 0.8, 0, Math.PI * 2);
        ctx.arc(cloud.x + 40, cloud.y, cloud.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // ç»˜åˆ¶åœ°é¢
      ctx.fillStyle = '#7bed9f';
      ctx.fillRect(0, 340, canvas.width, 60);
      ctx.fillStyle = '#2ed573';
      ctx.fillRect(0, 340, canvas.width, 4);

      const dog = dogRef.current;
      
      // å¦‚æœå°ç‹—ç¦»å¼€åœ°é¢ï¼Œå¼ºåˆ¶åœæ­¢è“„åŠ›
      if (dog.y < 300) {
        dog.isCharging = false;
      }
      
      // è“„åŠ›é€»è¾‘ - ä»…åœ¨å°ç‹—åœ¨åœ°é¢ä¸Šæ—¶æ‰èƒ½è“„åŠ›
      if (dog.y >= 300 && jumpKeyPressedRef.current) {
        dog.jumpPower = Math.min(dog.jumpPower + 0.4, dog.maxJumpPower);
      }
      
      // ç‰©ç†å¼•æ“
      dog.velocityY += 0.7; // é‡åŠ›
      dog.y += dog.velocityY;

      if (dog.y > 300) {
        dog.y = 300;
        dog.velocityY = 0;
        if (!jumpKeyPressedRef.current) dog.jumpPower = 0;
      }

      drawDog(ctx, dog);

      // ç”Ÿæˆéšœç¢ç‰©
      const now = Date.now();
      const currentInterval = Math.max(
        settings.minSpawnInterval,
        settings.spawnInterval - gameTimeRef.current * 15
      );
      
      if (now - lastSpawnTime > currentInterval) {
        const height = 40 + Math.random() * 50;
        const width = 30 + Math.random() * 20;
        obstaclesRef.current.push({
          x: canvas.width + 50,
          y: 340 - height,
          width: width,
          height: height,
          color: ['#ff6b81', '#ffa502', '#2f3542'][Math.floor(Math.random()*3)]
        });
        lastSpawnTime = now;
      }

      // éšœç¢ç‰©é€»è¾‘ä¸æ¸²æŸ“
      obstaclesRef.current = obstaclesRef.current.filter(obs => {
        obs.x -= currentSpeed;
        
        // ç»˜åˆ¶éšœç¢ç‰© (ä»™äººæŒé£æ ¼)
        ctx.fillStyle = obs.color;
        ctx.beginPath();
        drawRoundedRect(ctx, obs.x, obs.y, obs.width, obs.height, 5);
        ctx.fill();
        // å¢åŠ ä¸€ç‚¹è£…é¥°çº¿
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 2;
        ctx.strokeRect(obs.x + 5, obs.y + 5, obs.width - 10, obs.height - 10);

        // ç¢°æ’æ£€æµ‹ (ç¨å¾®ç¼©å°åˆ¤å®šåŒºä»¥æ›´å…¬å¹³)
        const hitboxPadding = 5;
        if (
          dog.x + hitboxPadding < obs.x + obs.width &&
          dog.x + dog.width - hitboxPadding > obs.x &&
          dog.y + hitboxPadding < obs.y + obs.height &&
          dog.y + dog.height - hitboxPadding > obs.y
        ) {
          setGameState('gameOver');
          setHighScore(prev => Math.max(prev, Math.floor(gameTimeRef.current * 10)));
          cancelAnimationFrame(gameLoopRef.current);
        }

        return obs.x + obs.width > -50;
      });

      // UI æ–‡æœ¬
      ctx.fillStyle = '#2f3542';
      ctx.font = 'bold 22px Arial';
      ctx.fillText(`åˆ†æ•°: ${Math.floor(gameTimeRef.current * 10)}`, 25, 45);
      
      gameLoopRef.current = requestAnimationFrame(gameLoop);
    };

    gameLoop();

    return () => {
      if (gameLoopRef.current) cancelAnimationFrame(gameLoopRef.current);
    };
  }, [gameState, difficulty]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-blue-50 p-4 font-sans select-none">
      <div className="bg-white rounded-2xl shadow-2xl p-6 max-w-4xl w-full border-4 border-white">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-black text-gray-800 tracking-tight">
            DOGGY <span className="text-blue-500">JUMP</span> ğŸ¶
          </h1>
          {highScore > 0 && (
            <div className="bg-yellow-100 px-4 py-1 rounded-full border border-yellow-200">
              <span className="text-yellow-700 font-bold">æœ€é«˜åˆ†: {highScore}</span>
            </div>
          )}
        </div>
        
        <div className="relative overflow-hidden rounded-xl bg-gray-100 aspect-[2/1] cursor-pointer">
          {gameState === 'menu' && (
            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-white/80 backdrop-blur-sm">
              <p className="text-xl text-gray-700 mb-8 font-medium">é•¿æŒ‰ç©ºæ ¼/å±å¹•è“„åŠ›ï¼Œé‡Šæ”¾è·³è·ƒï¼</p>
              
              <div className="flex gap-4 mb-10">
                {['easy', 'medium', 'hard'].map(level => (
                  <button
                    key={level}
                    onClick={(e) => { e.stopPropagation(); setDifficulty(level); }}
                    className={`px-6 py-2 rounded-full font-bold transition-all ${
                      difficulty === level
                        ? 'bg-blue-600 text-white scale-110 shadow-lg'
                        : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
                    }`}
                  >
                    {level === 'easy' ? 'æ‚ é—²' : level === 'medium' ? 'æ ‡å‡†' : 'ç–¯ç‹‚'}
                  </button>
                ))}
              </div>
              
              <button
                onClick={startGame}
                className="group relative px-12 py-4 bg-green-500 text-white rounded-2xl font-black text-2xl hover:bg-green-600 transition-all hover:scale-105 active:scale-95 shadow-[0_6px_0_rgb(22,163,74)] active:shadow-none active:translate-y-1"
              >
                å¼€å§‹å¥”è·‘!
              </button>

              <a
                href="https://pengzhiyi.top"
                className="mt-6 px-8 py-2 bg-gray-400 text-white rounded-xl font-bold text-lg hover:bg-gray-500 transition-all"
              >
                â† å›åˆ°ä¸»é¡µ
              </a>
            </div>
          )}

          {gameState === 'playing' && (
            <canvas
              ref={canvasRef}
              width={800}
              height={400}
              className="w-full h-full block"
            />
          )}

          {gameState === 'gameOver' && (
            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black/60 backdrop-blur-md">
              <h2 className="text-5xl font-black text-white mb-2 tracking-tighter italic">GAME OVER</h2>
              <p className="text-3xl text-yellow-400 font-bold mb-8">å¾—åˆ†: {score}</p>
              
              <div className="flex gap-4">
                <button
                  onClick={startGame}
                  className="px-10 py-4 bg-blue-500 text-white rounded-xl font-bold text-xl hover:bg-blue-600 transition-all shadow-[0_4px_0_rgb(37,99,235)] active:shadow-none active:translate-y-1"
                >
                  å†è¯•ä¸€æ¬¡
                </button>
                <button
                  onClick={() => setGameState('menu')}
                  className="px-10 py-4 bg-gray-600 text-white rounded-xl font-bold text-xl hover:bg-gray-700 transition-all"
                >
                  ä¸»èœå•
                </button>
              </div>
            </div>
          )}
        </div>
        
        <div className="mt-6 flex justify-between items-center text-gray-500 text-sm font-medium">
          <div className="flex items-center gap-4">
            <span className="flex items-center gap-1">âŒ¨ï¸ <kbd className="bg-gray-100 px-2 py-1 rounded shadow-sm">Space</kbd> è“„åŠ›è·³è·ƒ</span>
            <span className="flex items-center gap-1">ğŸ“± <span className="bg-gray-100 px-2 py-1 rounded shadow-sm">ç‚¹å‡»å±å¹•</span> è“„åŠ›è·³è·ƒ</span>
          </div>
          <p>éš¾åº¦: {difficulty.toUpperCase()}</p>
        </div>
      </div>
    </div>
  );
};

    ;

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<DogJumpGame />);
  </script>
</body>
</html>